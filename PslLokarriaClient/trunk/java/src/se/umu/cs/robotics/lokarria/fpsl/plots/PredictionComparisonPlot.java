/*-------------------------------------------------------------------*\
THIS SOURCE IS PART OF THE HPL-FRAMEWORK - www.cognitionreversed.com

Copyright (C) 2007 - 2015  Erik Billing, <http://www.his.se/erikb>
School of Informatics, University of Skovde, Sweden

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
\*-------------------------------------------------------------------*/

package se.umu.cs.robotics.lokarria.fpsl.plots;

import se.umu.cs.robotics.lokarria.fpsl.LokarriaPslPredictor.Predictions;
import java.util.Date;
import se.umu.cs.robotics.utils.StringTools;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import se.umu.cs.robotics.lokarria.fpsl.LokarriaPslPredictor;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Locale;
import se.umu.cs.robotics.fpsl.responsibility.ResponsibilitySignal;

/**
 *
 *
 * @author Erik Billing <billing@cs.umu.se>
 */
public class PredictionComparisonPlot {

    private final FileWriter out;
    private int responsibilityScaling = 3;

    public PredictionComparisonPlot(String name) throws IOException {
        File file = new File(String.format("plots/%s.py", name));
        out = new FileWriter(file);
    }

    public void render(LokarriaPslPredictor.Predictions... predictions) throws IOException {
        renderHead();

        out.write("predictions = ");
        renderData(predictions);
        out.write("\n");
        out.write("responsibilities = ");
        renderResponsibilities(predictions);
        out.write("\n\n");

        renderImports();

        out.write("fig = pyplot.figure()\n");
        out.write("errorAxes = fig.add_subplot(211)\n");
        out.write("pyplot.title('PSL prediction error')\n");
        out.write("errorLines = errorAxes.plot(np.array(predictions), '--', lw=1, alpha=0.7)\n");
        out.write("responsibilityAxes = fig.add_subplot(212)\n");
        out.write("pyplot.title('Responsibility signal')\n");
        out.write("lines = responsibilityAxes.plot(np.array(responsibilities), '-o', lw=1, alpha=0.7)\n");
    }

    public void renderLegends(String... legends) throws IOException {
        out.write("pyplot.legend(lines,['");
        out.write(StringTools.join(legends, "','"));
        out.write("'])\n");
    }

    private void renderData(LokarriaPslPredictor.Predictions... predictions) throws IOException {
        out.write("[");
        ArrayList<Iterator<Double>> iterators = new ArrayList<Iterator<Double>>();
        for (LokarriaPslPredictor.Predictions p : predictions) {
            iterators.add(p.getAverageLaserDistances().iterator());
        }
        while (true) {
            out.write("[");
            for (Iterator<Double> i : iterators) {
                out.write(String.format(Locale.US, "%.6f", i.next()));
                out.write(",");
            }
            out.write("]");
            out.write(",");
            if (!iterators.get(0).hasNext()) {
                break;
            }
        }
        out.write("]\n");
    }

    private void renderHead() throws IOException {
        out.write("'''\n");
        out.write("\tPlot generated by ");
        out.write(this.getClass().getSimpleName());
        out.write("\n\t");
        out.write(new Date().toString());
        out.write("\n'''\n\n");
    }

    private void renderImports() throws IOException {
        out.write("import numpy as np\n");
        out.write("import sys, time\n");
        out.write("from matplotlib import pyplot\n");
        out.write("from matplotlib.lines import Line2D\n");
        out.write("from matplotlib.patches import Patch, Rectangle\n");
        out.write("from matplotlib.font_manager import FontProperties\n");
        out.write("\n");
    }

    public void close() throws IOException {
        out.write("pyplot.show()\n");
        out.close();
    }

    private void renderResponsibilities(Predictions[] predictions) throws IOException {
        ResponsibilitySignal responsibility = new ResponsibilitySignal(predictions.length, responsibilityScaling);

        out.write("[");
        ArrayList<Iterator<Double>> iterators = new ArrayList<Iterator<Double>>();
        for (LokarriaPslPredictor.Predictions p : predictions) {
            iterators.add(p.getAverageLaserDistances().iterator());
        }
        while (true) {
            out.write("[");
            double[] errors = new double[iterators.size()];
            for (int i = 0; i < errors.length; i++) {
                errors[i] = iterators.get(i).next();
            }
            responsibility.update(errors);
            for (int i = 0; i < errors.length; i++) {
                out.write(String.format(Locale.US, "%.6f", responsibility.get(i)));
                out.write(",");
            }
            out.write("]");
            if (iterators.get(0).hasNext()) {
                out.write(",");
            } else {
                break;
            }
        }
        out.write("]\n");
    }
}

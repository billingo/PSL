/*-------------------------------------------------------------------*\
THIS SOURCE IS PART OF THE HPL-FRAMEWORK - www.cognitionreversed.com

Copyright 2011 Erik Billing
Department of Computing Science, Umea University, Sweden,
(http://www.cognitionreversed.com).

LICENSE:

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston,
MA 02111-1307, USA.
\*-------------------------------------------------------------------*/
package se.umu.cs.robotics.lokarria.fpsl.plots;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.Locale;
import se.umu.cs.robotics.fpsl.FHypothesis;
import se.umu.cs.robotics.fpsl.selection.FLhsMatch;
import se.umu.cs.robotics.fpsl.FPrediction;
import se.umu.cs.robotics.fpsl.selection.FHypothesisMatch;
import se.umu.cs.robotics.fpsl.selection.FHypothesisSelection;
import se.umu.cs.robotics.lokarria.fpsl.LokarriaPslPredictor;
import se.umu.cs.robotics.lokarria.statespace.SensoryMotorDistribution;
import se.umu.cs.robotics.probabilitydistribution.FuzzyDistribution;
import se.umu.cs.robotics.probabilitydistribution.ProbabilityDistribution;
import se.umu.cs.robotics.probabilitydistribution.SingleStateDistribution;
import se.umu.cs.robotics.probabilitydistribution.SpaceDistribution;
import se.umu.cs.robotics.utils.FileTools;
import se.umu.cs.robotics.utils.MathTools;

/**
 *
 *
 * @author Erik Billing <billing@cs.umu.se>
 */
public class LokarriaPslPredictorPlot {

    private final LokarriaPslPredictor predictor;
    private final LokarriaPslPredictor.Predictions predictions;

    public LokarriaPslPredictorPlot(LokarriaPslPredictor predictor, LokarriaPslPredictor.Predictions predictions) {
        this.predictor = predictor;
        this.predictions = predictions;
    }

    public void render(Writer out) throws IOException {
        out.write("'''\n");
        out.write("\tPlot generated by ");
        out.write(this.getClass().getSimpleName());
        out.write("\n\t");
        out.write(new Date().toString());
        out.write("\n'''\n\n");

        renderAverageStatistics(out);
        out.write('\n');
        out.write('\n');

        renderImports(out);

        out.write("\nfig = pyplot.figure()\n");
        out.write("ax = fig.add_subplot(211)\n");
        renderPickHandler(out);
        renderHypothesisClass(out);

        out.write("\n# DATA\n");
        renderData(out);
        renderFacit(out);
        renderPredictions(out);
        renderAnnotations(out);
        renderHypotheses(out);

        out.write("lines = ax.plot(data, '-o', ms=6, lw=1, alpha=0.7, picker=3)\n");
        out.write("ax.grid()\n");
        out.write("pyplot.legend(lines,('Intersection','Max-prediction','Linear distances'),prop=FontProperties(size=10))\n");
        out.write("detail = fig.add_subplot(212)\n");

        out.write("pyplot.show()\n");
        out.write("\n");
        out.write("\n");
    }

    private void renderAverageStatistics(Writer out) throws IOException {
        double avgIntersection = MathTools.mean(predictions.getIntersections());
        double avgDistance = MathTools.mean(predictions.getAverageLaserDistances());
        double angularSpeedError = MathTools.mean(predictions.getAngularSpeedErrors());
        double linearSpeedError = MathTools.mean(predictions.getLinearSpeedErrors());
        double avgLength = MathTools.mean(predictions.getHypothesesLengths());
        final int[] matchCounts = predictions.getHypothesisMatchCounts();

        out.write(String.format(Locale.US, "avgIntersection = %.5f\n", avgIntersection));
        out.write(String.format(Locale.US, "avgLaserDistance = %.5f\n", avgDistance));
        out.write(String.format(Locale.US, "angularSpeedError = %.5f\n", angularSpeedError));
        out.write(String.format(Locale.US, "linearSpeedError = %.5f\n", linearSpeedError));
        out.write(String.format(Locale.US, "avgLength = %.5f\n", avgLength));
        out.write(String.format(Locale.US, "avgMatchCount = %.5f\n", MathTools.mean(matchCounts)));
        out.write(String.format(Locale.US, "maxMatchCount = %d\n", MathTools.max(matchCounts)));
    }

    private void renderImports(Writer out) throws IOException {
        out.write("import numpy as np\n");
        out.write("from matplotlib import pyplot\n");
        out.write("from matplotlib.lines import Line2D\n");
        out.write("from matplotlib.patches import Patch, Rectangle\n");
        out.write("from matplotlib.font_manager import FontProperties\n");
    }

    private void renderData(Writer out) throws IOException {
        out.write("data = np.array([");
        Iterator<Double> intersections = predictions.getIntersections().iterator();
        Iterator<Double> maxComparison = predictions.getMaxComparison().iterator();
        Iterator<Double> linearErrors;
        linearErrors = predictions.getAngularSpeedErrors().iterator();
        for (FHypothesisSelection<Double> prediction : predictions.getPredictions()) {
            out.write("[");
            out.write(intersections.next().toString());
            out.write(",");
            out.write(maxComparison.next().toString());
            out.write(",");
            final Double error = linearErrors.next();
            if (error == null) {
                out.write("None");
            } else {
                out.write(error.toString());
            }
            out.write("]");
            out.write(",");
        }
        out.write("])\n");
    }

    private void renderFacit(Writer out) throws IOException {
        out.write("facit = np.array([");
        for (int i = 0; i < predictions.size(); i++) {
            renderDistribution(out, predictions.getCorrect(i));
            out.write(',');
        }
        out.write("])\n");
    }

    private void renderPredictions(Writer out) throws IOException {
        out.write("predictions = np.array([");
        for (int i = 0; i < predictions.size(); i++) {
            renderDistribution(out, predictions.getPrediction(i).getTarget());
            out.write(',');
        }
        out.write("])\n");
    }

    private void renderAnnotations(Writer out) throws IOException {
        out.write("annotations = [");
        int i = 0;
        for (FHypothesisSelection<Double> prediction : predictions.getPredictions()) {
            ArrayList<FHypothesis> matches = new ArrayList<FHypothesis>();
            SensoryMotorDistribution facit = predictions.getCorrect(i);
            out.write(String.format("\n\t(\"t=%d", i));
//            renderPredictionAnnotation(out, prediction);
//            Selection match = prediction.getSelection();
//            for (FHypothesis root : predictor.getLibrary().getRoots()) {
//                FLhsMatch hMatch = match.bestMatch(root);
//                if (hMatch != null) {
//                    FHypothesis h = hMatch.getHypothesis();
//                    out.write(String.format("Hypothesis %d: len=%d intersection=%.3f match=%.3f conf=%.3f\\n", h.getId(), h.length(), h.getTarget().intersection(facit), hMatch.getValue(), h.getConfidence()));
//                    lengths.add((double) h.length());
//                    getMatches.add(h);
//                }
//            }
            out.write("\",\"");
            for (FHypothesis h : matches) {
                out.write(h.toString());
                out.write("\\n");
            }
            out.write("\"),");
            i++;
        }
        out.write("\n]\n");
    }

    private void renderPredictionAnnotation(Writer out, FPrediction<Double> prediction) throws IOException {
        Iterator<? extends ProbabilityDistribution<Double>> dimensions = prediction.element().dimensions();
        out.write("Prediction: (");
        boolean first = true;
        while (dimensions.hasNext()) {
            ProbabilityDistribution<Double> dist = dimensions.next();
            if (first) {
                first = false;
            } else {
                out.write(";");
            }
            if (dist == null || dist.isUniform()) {
                out.write("-");
            } else if (dist instanceof FuzzyDistribution) {
                double center = ((FuzzyDistribution) dist).centerOfSum();
                out.write(String.format("%.0f", center));
            } else {
                out.write(dist.toString());
            }
        }
        out.write(")\\n");
    }

    private void renderHypotheses(Writer out) throws IOException {
        out.write("hypotheses = [");
        int i = 0;
        for (FHypothesisSelection<Double> selection : predictions.getPredictions()) {
            SensoryMotorDistribution facit = predictions.getCorrect(i);
            out.write(String.format("\n\t[", facit.toString()));
            for (FHypothesisMatch match : selection.getTargetHypotheses()) {
                renderHypothesis(out, match);
                out.write(',');
            }
            out.write("],");
            i++;
        }
        out.write("\n]\n");
    }

    private void renderHypothesisClass(Writer out) throws IOException {
        out.write("class Hypothesis:\n");
        out.write("\tdef __init__(self,id,confidence,dist,match):\n");
        out.write("\t\tself.id,self.confidence,self.dist,self.match=id,confidence,dist,match\n");
        out.write('\n');
    }

    private void renderHypothesis(Writer out, FHypothesisMatch match) throws IOException {
        FHypothesis h = match.getHypothesis();
        out.write("Hypothesis(");
        out.write(new Integer(h.getId()).toString());
        out.write(',');
        out.write(Double.toString(h.getConfidence()));
        out.write(',');
        renderDistribution(out, h.getTarget());
        out.write(',');
        out.write(Double.toString(match.getValue()));
        out.write(")");
    }

    private void renderDistribution(Writer out, SpaceDistribution dist) throws IOException {
        out.write("(");
        Iterator<? extends ProbabilityDistribution> dimensions = dist.dimensions();
        while (dimensions.hasNext()) {
            ProbabilityDistribution d = dimensions.next();
            if (d instanceof SingleStateDistribution) {
                out.write(((SingleStateDistribution) d).getState().toString());
            } else if (d instanceof FuzzyDistribution) {
                out.write(new Double(((FuzzyDistribution) d).defuzzify()).toString());
            } else {
                out.write("0");
            }
            out.write(',');
        }
        out.write(")");
    }

    private void renderPickHandler(Writer out) throws IOException {
        out.write('\n');
        out.write(FileTools.readFile("plots/PickHandler.py"));
        out.write("\nfig.canvas.mpl_connect('pick_event', PickHandler())\n");
        out.write('\n');
    }
}
